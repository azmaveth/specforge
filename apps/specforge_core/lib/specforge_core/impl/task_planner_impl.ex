defmodule SpecforgeCore.Impl.TaskPlannerImpl do
  @moduledoc """
  Default implementation of the TaskPlanner behaviour.
  """
  @behaviour SpecforgeCore.TaskPlanner

  alias ExLLM
  
  @impl true
  def analyze_task(task_description, options \\ %{}) do
    with {:ok, validated} <- maybe_validate(task_description, options),
         {:ok, plan} <- maybe_cached_generate_plan(validated, options) do
      render_with_template(plan, Map.get(options, :template))
    end
  end

  @impl true
  def validate_task(task_description) do
    # TODO: Implement validation logic
    # For now, just check if the description is not empty
    if String.trim(task_description) == "" do
      {:error, "Task description cannot be empty"}
    else
      {:ok, task_description}
    end
  end

  @impl true
  def render_with_template(plan, nil) do
    # Use default template
    complexity = Map.get(plan, :complexity, "medium")
    estimated_hours = Map.get(plan, :estimated_hours, "N/A")
    
    rendered = """
    # Task Plan
    
    ## Overview
    #{Map.get(plan, :overview, "No overview provided")}
    
    **Complexity:** #{String.capitalize(complexity)}  
    **Estimated Time:** #{estimated_hours} hours
    
    ## Implementation Steps
    #{format_steps(Map.get(plan, :steps, []))}
    
    ## Important Considerations
    #{format_considerations(Map.get(plan, :considerations, []))}
    
    ---
    *Generated by SpecForge TaskPlanner*
    """
    {:ok, rendered}
  end

  def render_with_template(_plan, _template_path) do
    # TODO: Load and render custom template
    {:error, "Custom templates not yet implemented"}
  end

  defp maybe_validate(task_description, %{validate: false}), do: {:ok, task_description}
  defp maybe_validate(task_description, _options), do: validate_task(task_description)

  defp generate_plan(task_description, options) do
    model = Map.get(options, :model, Application.get_env(:specforge_core, :default_model, "openai"))
    
    prompt = build_task_planning_prompt(task_description, options)
    
    case ExLLM.chat(model, [%{role: "user", content: prompt}]) do
      {:ok, response} ->
        parse_llm_response(response.content, task_description)
      
      {:error, reason} ->
        # Fallback to structured plan on LLM failure
        IO.puts("Warning: LLM failed (#{inspect(reason)}), using fallback plan")
        generate_fallback_plan(task_description)
    end
  end
  
  defp build_task_planning_prompt(task_description, options) do
    search_context = if Map.get(options, :search), do: "\nPlease consider web search context if relevant.", else: ""
    
    """
    You are a technical task planning assistant. Analyze the following task and create a comprehensive implementation plan.

    Task: #{task_description}#{search_context}

    Please provide a response in the following JSON format:
    {
      "overview": "Brief overview of what this task involves",
      "steps": [
        "Step 1: Specific action item",
        "Step 2: Another specific action item",
        "..."
      ],
      "considerations": [
        "Important consideration or constraint",
        "Another important point to remember",
        "..."
      ],
      "complexity": "low|medium|high",
      "estimated_hours": number
    }

    Focus on:
    - Concrete, actionable steps
    - Technical considerations and constraints
    - Dependencies and prerequisites
    - Testing and validation requirements
    - Security and performance implications
    
    Respond with valid JSON only.
    """
  end
  
  defp parse_llm_response(response, task_description) do
    try do
      parsed = Jason.decode!(response)
      
      plan = %{
        overview: Map.get(parsed, "overview", "Plan for: #{task_description}"),
        steps: Map.get(parsed, "steps", []),
        considerations: Map.get(parsed, "considerations", []),
        complexity: Map.get(parsed, "complexity", "medium"),
        estimated_hours: Map.get(parsed, "estimated_hours", 4)
      }
      
      {:ok, plan}
    rescue
      Jason.DecodeError ->
        # If JSON parsing fails, try to extract useful information from raw text
        parse_text_response(response, task_description)
    end
  end
  
  defp parse_text_response(response, task_description) do
    # Simple text parsing fallback
    lines = String.split(response, "\n") |> Enum.map(&String.trim/1) |> Enum.reject(&(&1 == ""))
    
    # Try to extract steps (lines that start with numbers or bullets)
    steps = Enum.filter(lines, fn line ->
      String.match?(line, ~r/^\d+\.|\*|\-/) 
    end)
    |> Enum.map(fn line ->
      String.replace(line, ~r/^\d+\.\s*|\*\s*|\-\s*/, "")
    end)
    
    plan = %{
      overview: "Analysis of: #{task_description}",
      steps: if(length(steps) > 0, do: steps, else: ["Review requirements", "Plan implementation", "Execute plan"]),
      considerations: ["Ensure thorough testing", "Consider scalability requirements"],
      complexity: "medium",
      estimated_hours: 4
    }
    
    {:ok, plan}
  end
  
  defp generate_fallback_plan(task_description) do
    plan = %{
      overview: "Plan for: #{task_description}",
      steps: [
        "Analyze requirements and constraints",
        "Design solution architecture", 
        "Implement core functionality",
        "Add error handling and validation",
        "Write comprehensive tests",
        "Review and optimize performance"
      ],
      considerations: [
        "Consider edge cases and error scenarios",
        "Ensure scalability and maintainability",
        "Follow security best practices",
        "Document implementation decisions"
      ],
      complexity: "medium",
      estimated_hours: 6
    }
    {:ok, plan}
  end

  defp format_steps(steps) do
    steps
    |> Enum.with_index(1)
    |> Enum.map_join("\n", fn {step, idx} -> "#{idx}. #{step}" end)
  end

  defp format_considerations(considerations) do
    Enum.map_join(considerations, "\n", fn c -> "- #{c}" end)
  end

  defp maybe_cached_generate_plan(task_description, options) do
    if Map.get(options, :cache, true) do
      cache_key = SpecforgeCore.Cache.generate_key(:task_plan, {task_description, options})
      
      SpecforgeCore.Cache.fetch(cache_key, fn ->
        generate_plan(task_description, options)
      end)
    else
      generate_plan(task_description, options)
    end
  end
end